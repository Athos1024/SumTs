{"version":3,"names":[],"mappings":"","sources":["Astar.js"],"sourcesContent":["/**\n*   EasyStar.js\n*   github.com/prettymuchbryce/EasyStarJS\n*   Licensed under the MIT license.\n*\n*   Implementation By Bryce Neal (@prettymuchbryce)\n**/\nvar EasyStar = {};\nvar Instance = require('./instance');\nvar Node = require('./node');\nvar Heap = require('heap');\nconst CLOSED_LIST = 0;\nconst OPEN_LIST = 1;\nmodule.exports = EasyStar;\nvar nextInstanceId = 1;\nEasyStar.js = function () {\n    var STRAIGHT_COST = 1.0;\n    var DIAGONAL_COST = 1.4;\n    var syncEnabled = false;\n    var pointsToAvoid = {};\n    var collisionGrid;\n    var costMap = {};\n    var pointsToCost = {};\n    var directionalConditions = {};\n    var allowCornerCutting = true;\n    var iterationsSoFar;\n    var instances = {};\n    var instanceQueue = [];\n    var iterationsPerCalculation = Number.MAX_VALUE;\n    var acceptableTiles;\n    var diagonalsEnabled = false;\n    /**\n    * Sets the collision grid that EasyStar uses.\n    *\n    * @param {Array|Number} tiles An array of numbers that represent\n    * which tiles in your grid should be considered\n    * acceptable, or \"walkable\".\n    **/\n    this.setAcceptableTiles = function (tiles) {\n        if (tiles instanceof Array) {\n            // Array\n            acceptableTiles = tiles;\n        }\n        else if (!isNaN(parseFloat(tiles)) && isFinite(tiles)) {\n            // Number\n            acceptableTiles = [tiles];\n        }\n    };\n    /**\n    * Enables sync mode for this EasyStar instance..\n    * if you're into that sort of thing.\n    **/\n    this.enableSync = function () {\n        syncEnabled = true;\n    };\n    /**\n    * Disables sync mode for this EasyStar instance.\n    **/\n    this.disableSync = function () {\n        syncEnabled = false;\n    };\n    /**\n     * Enable diagonal pathfinding.\n     */\n    this.enableDiagonals = function () {\n        diagonalsEnabled = true;\n    };\n    /**\n     * Disable diagonal pathfinding.\n     */\n    this.disableDiagonals = function () {\n        diagonalsEnabled = false;\n    };\n    /**\n    * Sets the collision grid that EasyStar uses.\n    *\n    * @param {Array} grid The collision grid that this EasyStar instance will read from.\n    * This should be a 2D Array of Numbers.\n    **/\n    this.setGrid = function (grid) {\n        collisionGrid = grid;\n        //Setup cost map\n        for (var y = 0; y < collisionGrid.length; y++) {\n            for (var x = 0; x < collisionGrid[0].length; x++) {\n                if (!costMap[collisionGrid[y][x]]) {\n                    costMap[collisionGrid[y][x]] = 1;\n                }\n            }\n        }\n    };\n    /**\n    * Sets the tile cost for a particular tile type.\n    *\n    * @param {Number} The tile type to set the cost for.\n    * @param {Number} The multiplicative cost associated with the given tile.\n    **/\n    this.setTileCost = function (tileType, cost) {\n        costMap[tileType] = cost;\n    };\n    /**\n    * Sets the an additional cost for a particular point.\n    * Overrides the cost from setTileCost.\n    *\n    * @param {Number} x The x value of the point to cost.\n    * @param {Number} y The y value of the point to cost.\n    * @param {Number} The multiplicative cost associated with the given point.\n    **/\n    this.setAdditionalPointCost = function (x, y, cost) {\n        if (pointsToCost[y] === undefined) {\n            pointsToCost[y] = {};\n        }\n        pointsToCost[y][x] = cost;\n    };\n    /**\n    * Remove the additional cost for a particular point.\n    *\n    * @param {Number} x The x value of the point to stop costing.\n    * @param {Number} y The y value of the point to stop costing.\n    **/\n    this.removeAdditionalPointCost = function (x, y) {\n        if (pointsToCost[y] !== undefined) {\n            delete pointsToCost[y][x];\n        }\n    };\n    /**\n    * Remove all additional point costs.\n    **/\n    this.removeAllAdditionalPointCosts = function () {\n        pointsToCost = {};\n    };\n    /**\n    * Sets a directional condition on a tile\n    *\n    * @param {Number} x The x value of the point.\n    * @param {Number} y The y value of the point.\n    * @param {Array.<String>} allowedDirections A list of all the allowed directions that can access\n    * the tile.\n    **/\n    this.setDirectionalCondition = function (x, y, allowedDirections) {\n        if (directionalConditions[y] === undefined) {\n            directionalConditions[y] = {};\n        }\n        directionalConditions[y][x] = allowedDirections;\n    };\n    /**\n    * Remove all directional conditions\n    **/\n    this.removeAllDirectionalConditions = function () {\n        directionalConditions = {};\n    };\n    /**\n    * Sets the number of search iterations per calculation.\n    * A lower number provides a slower result, but more practical if you\n    * have a large tile-map and don't want to block your thread while\n    * finding a path.\n    *\n    * @param {Number} iterations The number of searches to prefrom per calculate() call.\n    **/\n    this.setIterationsPerCalculation = function (iterations) {\n        iterationsPerCalculation = iterations;\n    };\n    /**\n    * Avoid a particular point on the grid,\n    * regardless of whether or not it is an acceptable tile.\n    *\n    * @param {Number} x The x value of the point to avoid.\n    * @param {Number} y The y value of the point to avoid.\n    **/\n    this.avoidAdditionalPoint = function (x, y) {\n        if (pointsToAvoid[y] === undefined) {\n            pointsToAvoid[y] = {};\n        }\n        pointsToAvoid[y][x] = 1;\n    };\n    /**\n    * Stop avoiding a particular point on the grid.\n    *\n    * @param {Number} x The x value of the point to stop avoiding.\n    * @param {Number} y The y value of the point to stop avoiding.\n    **/\n    this.stopAvoidingAdditionalPoint = function (x, y) {\n        if (pointsToAvoid[y] !== undefined) {\n            delete pointsToAvoid[y][x];\n        }\n    };\n    /**\n    * Enables corner cutting in diagonal movement.\n    **/\n    this.enableCornerCutting = function () {\n        allowCornerCutting = true;\n    };\n    /**\n    * Disables corner cutting in diagonal movement.\n    **/\n    this.disableCornerCutting = function () {\n        allowCornerCutting = false;\n    };\n    /**\n    * Stop avoiding all additional points on the grid.\n    **/\n    this.stopAvoidingAllAdditionalPoints = function () {\n        pointsToAvoid = {};\n    };\n    /**\n    * Find a path.\n    *\n    * @param {Number} startX The X position of the starting point.\n    * @param {Number} startY The Y position of the starting point.\n    * @param {Number} endX The X position of the ending point.\n    * @param {Number} endY The Y position of the ending point.\n    * @param {Function} callback A function that is called when your path\n    * is found, or no path is found.\n    * @return {Number} A numeric, non-zero value which identifies the created instance. This value can be passed to cancelPath to cancel the path calculation.\n    *\n    **/\n    this.findPath = function (startX, startY, endX, endY, callback) {\n        // Wraps the callback for sync vs async logic\n        var callbackWrapper = function (result) {\n            if (syncEnabled) {\n                callback(result);\n            }\n            else {\n                setTimeout(function () {\n                    callback(result);\n                });\n            }\n        };\n        // No acceptable tiles were set\n        if (acceptableTiles === undefined) {\n            throw new Error(\"You can't set a path without first calling setAcceptableTiles() on EasyStar.\");\n        }\n        // No grid was set\n        if (collisionGrid === undefined) {\n            throw new Error(\"You can't set a path without first calling setGrid() on EasyStar.\");\n        }\n        // Start or endpoint outside of scope.\n        if (startX < 0 || startY < 0 || endX < 0 || endY < 0 ||\n            startX > collisionGrid[0].length - 1 || startY > collisionGrid.length - 1 ||\n            endX > collisionGrid[0].length - 1 || endY > collisionGrid.length - 1) {\n            throw new Error(\"Your start or end point is outside the scope of your grid.\");\n        }\n        // Start and end are the same tile.\n        if (startX === endX && startY === endY) {\n            callbackWrapper([]);\n            return;\n        }\n        // End point is not an acceptable tile.\n        var endTile = collisionGrid[endY][endX];\n        var isAcceptable = false;\n        for (var i = 0; i < acceptableTiles.length; i++) {\n            if (endTile === acceptableTiles[i]) {\n                isAcceptable = true;\n                break;\n            }\n        }\n        if (isAcceptable === false) {\n            callbackWrapper(null);\n            return;\n        }\n        // Create the instance\n        var instance = new Instance();\n        instance.openList = new Heap(function (nodeA, nodeB) {\n            return nodeA.bestGuessDistance() - nodeB.bestGuessDistance();\n        });\n        instance.isDoneCalculating = false;\n        instance.nodeHash = {};\n        instance.startX = startX;\n        instance.startY = startY;\n        instance.endX = endX;\n        instance.endY = endY;\n        instance.callback = callbackWrapper;\n        instance.openList.push(coordinateToNode(instance, instance.startX, instance.startY, null, STRAIGHT_COST));\n        var instanceId = nextInstanceId++;\n        instances[instanceId] = instance;\n        instanceQueue.push(instanceId);\n        return instanceId;\n    };\n    /**\n     * Cancel a path calculation.\n     *\n     * @param {Number} instanceId The instance ID of the path being calculated\n     * @return {Boolean} True if an instance was found and cancelled.\n     *\n     **/\n    this.cancelPath = function (instanceId) {\n        if (instanceId in instances) {\n            delete instances[instanceId];\n            // No need to remove it from instanceQueue\n            return true;\n        }\n        return false;\n    };\n    /**\n    * This method steps through the A* Algorithm in an attempt to\n    * find your path(s). It will search 4-8 tiles (depending on diagonals) for every calculation.\n    * You can change the number of calculations done in a call by using\n    * easystar.setIteratonsPerCalculation().\n    **/\n    this.calculate = function () {\n        if (instanceQueue.length === 0 || collisionGrid === undefined || acceptableTiles === undefined) {\n            return;\n        }\n        for (iterationsSoFar = 0; iterationsSoFar < iterationsPerCalculation; iterationsSoFar++) {\n            if (instanceQueue.length === 0) {\n                return;\n            }\n            if (syncEnabled) {\n                // If this is a sync instance, we want to make sure that it calculates synchronously.\n                iterationsSoFar = 0;\n            }\n            var instanceId = instanceQueue[0];\n            var instance = instances[instanceId];\n            if (typeof instance == 'undefined') {\n                // This instance was cancelled\n                instanceQueue.shift();\n                continue;\n            }\n            // Couldn't find a path.\n            if (instance.openList.size() === 0) {\n                instance.callback(null);\n                delete instances[instanceId];\n                instanceQueue.shift();\n                continue;\n            }\n            var searchNode = instance.openList.pop();\n            // Handles the case where we have found the destination\n            if (instance.endX === searchNode.x && instance.endY === searchNode.y) {\n                var path = [];\n                path.push({ x: searchNode.x, y: searchNode.y });\n                var parent = searchNode.parent;\n                while (parent != null) {\n                    path.push({ x: parent.x, y: parent.y });\n                    parent = parent.parent;\n                }\n                path.reverse();\n                var ip = path;\n                instance.callback(ip);\n                delete instances[instanceId];\n                instanceQueue.shift();\n                continue;\n            }\n            searchNode.list = CLOSED_LIST;\n            if (searchNode.y > 0) {\n                checkAdjacentNode(instance, searchNode, 0, -1, STRAIGHT_COST * getTileCost(searchNode.x, searchNode.y - 1));\n            }\n            if (searchNode.x < collisionGrid[0].length - 1) {\n                checkAdjacentNode(instance, searchNode, 1, 0, STRAIGHT_COST * getTileCost(searchNode.x + 1, searchNode.y));\n            }\n            if (searchNode.y < collisionGrid.length - 1) {\n                checkAdjacentNode(instance, searchNode, 0, 1, STRAIGHT_COST * getTileCost(searchNode.x, searchNode.y + 1));\n            }\n            if (searchNode.x > 0) {\n                checkAdjacentNode(instance, searchNode, -1, 0, STRAIGHT_COST * getTileCost(searchNode.x - 1, searchNode.y));\n            }\n            if (diagonalsEnabled) {\n                if (searchNode.x > 0 && searchNode.y > 0) {\n                    if (allowCornerCutting ||\n                        (isTileWalkable(collisionGrid, acceptableTiles, searchNode.x, searchNode.y - 1, searchNode) &&\n                            isTileWalkable(collisionGrid, acceptableTiles, searchNode.x - 1, searchNode.y, searchNode))) {\n                        checkAdjacentNode(instance, searchNode, -1, -1, DIAGONAL_COST * getTileCost(searchNode.x - 1, searchNode.y - 1));\n                    }\n                }\n                if (searchNode.x < collisionGrid[0].length - 1 && searchNode.y < collisionGrid.length - 1) {\n                    if (allowCornerCutting ||\n                        (isTileWalkable(collisionGrid, acceptableTiles, searchNode.x, searchNode.y + 1, searchNode) &&\n                            isTileWalkable(collisionGrid, acceptableTiles, searchNode.x + 1, searchNode.y, searchNode))) {\n                        checkAdjacentNode(instance, searchNode, 1, 1, DIAGONAL_COST * getTileCost(searchNode.x + 1, searchNode.y + 1));\n                    }\n                }\n                if (searchNode.x < collisionGrid[0].length - 1 && searchNode.y > 0) {\n                    if (allowCornerCutting ||\n                        (isTileWalkable(collisionGrid, acceptableTiles, searchNode.x, searchNode.y - 1, searchNode) &&\n                            isTileWalkable(collisionGrid, acceptableTiles, searchNode.x + 1, searchNode.y, searchNode))) {\n                        checkAdjacentNode(instance, searchNode, 1, -1, DIAGONAL_COST * getTileCost(searchNode.x + 1, searchNode.y - 1));\n                    }\n                }\n                if (searchNode.x > 0 && searchNode.y < collisionGrid.length - 1) {\n                    if (allowCornerCutting ||\n                        (isTileWalkable(collisionGrid, acceptableTiles, searchNode.x, searchNode.y + 1, searchNode) &&\n                            isTileWalkable(collisionGrid, acceptableTiles, searchNode.x - 1, searchNode.y, searchNode))) {\n                        checkAdjacentNode(instance, searchNode, -1, 1, DIAGONAL_COST * getTileCost(searchNode.x - 1, searchNode.y + 1));\n                    }\n                }\n            }\n        }\n    };\n    // Private methods follow\n    var checkAdjacentNode = function (instance, searchNode, x, y, cost) {\n        var adjacentCoordinateX = searchNode.x + x;\n        var adjacentCoordinateY = searchNode.y + y;\n        if ((pointsToAvoid[adjacentCoordinateY] === undefined ||\n            pointsToAvoid[adjacentCoordinateY][adjacentCoordinateX] === undefined) &&\n            isTileWalkable(collisionGrid, acceptableTiles, adjacentCoordinateX, adjacentCoordinateY, searchNode)) {\n            var node = coordinateToNode(instance, adjacentCoordinateX, adjacentCoordinateY, searchNode, cost);\n            if (node.list === undefined) {\n                node.list = OPEN_LIST;\n                instance.openList.push(node);\n            }\n            else if (searchNode.costSoFar + cost < node.costSoFar) {\n                node.costSoFar = searchNode.costSoFar + cost;\n                node.parent = searchNode;\n                instance.openList.updateItem(node);\n            }\n        }\n    };\n    // Helpers\n    var isTileWalkable = function (collisionGrid, acceptableTiles, x, y, sourceNode) {\n        var directionalCondition = directionalConditions[y] && directionalConditions[y][x];\n        if (directionalCondition) {\n            var direction = calculateDirection(sourceNode.x - x, sourceNode.y - y);\n            var directionIncluded = function () {\n                for (var i = 0; i < directionalCondition.length; i++) {\n                    if (directionalCondition[i] === direction)\n                        return true;\n                }\n                return false;\n            };\n            if (!directionIncluded())\n                return false;\n        }\n        for (var i = 0; i < acceptableTiles.length; i++) {\n            if (collisionGrid[y][x] === acceptableTiles[i]) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * -1, -1 | 0, -1  | 1, -1\n     * -1,  0 | SOURCE | 1,  0\n     * -1,  1 | 0,  1  | 1,  1\n     */\n    var calculateDirection = function (diffX, diffY) {\n        if (diffX === 0 && diffY === -1)\n            return EasyStar.TOP;\n        else if (diffX === 1 && diffY === -1)\n            return EasyStar.TOP_RIGHT;\n        else if (diffX === 1 && diffY === 0)\n            return EasyStar.RIGHT;\n        else if (diffX === 1 && diffY === 1)\n            return EasyStar.BOTTOM_RIGHT;\n        else if (diffX === 0 && diffY === 1)\n            return EasyStar.BOTTOM;\n        else if (diffX === -1 && diffY === 1)\n            return EasyStar.BOTTOM_LEFT;\n        else if (diffX === -1 && diffY === 0)\n            return EasyStar.LEFT;\n        else if (diffX === -1 && diffY === -1)\n            return EasyStar.TOP_LEFT;\n        throw new Error('These differences are not valid: ' + diffX + ', ' + diffY);\n    };\n    var getTileCost = function (x, y) {\n        return (pointsToCost[y] && pointsToCost[y][x]) || costMap[collisionGrid[y][x]];\n    };\n    var coordinateToNode = function (instance, x, y, parent, cost) {\n        if (instance.nodeHash[y] !== undefined) {\n            if (instance.nodeHash[y][x] !== undefined) {\n                return instance.nodeHash[y][x];\n            }\n        }\n        else {\n            instance.nodeHash[y] = {};\n        }\n        var simpleDistanceToTarget = getDistance(x, y, instance.endX, instance.endY);\n        if (parent !== null) {\n            var costSoFar = parent.costSoFar + cost;\n        }\n        else {\n            costSoFar = 0;\n        }\n        var node = new Node(parent, x, y, costSoFar, simpleDistanceToTarget);\n        instance.nodeHash[y][x] = node;\n        return node;\n    };\n    var getDistance = function (x1, y1, x2, y2) {\n        if (diagonalsEnabled) {\n            // Octile distance\n            var dx = Math.abs(x1 - x2);\n            var dy = Math.abs(y1 - y2);\n            if (dx < dy) {\n                return DIAGONAL_COST * dx + dy;\n            }\n            else {\n                return DIAGONAL_COST * dy + dx;\n            }\n        }\n        else {\n            // Manhattan distance\n            var dx = Math.abs(x1 - x2);\n            var dy = Math.abs(y1 - y2);\n            return (dx + dy);\n        }\n    };\n};\nEasyStar.TOP = 'TOP';\nEasyStar.TOP_RIGHT = 'TOP_RIGHT';\nEasyStar.RIGHT = 'RIGHT';\nEasyStar.BOTTOM_RIGHT = 'BOTTOM_RIGHT';\nEasyStar.BOTTOM = 'BOTTOM';\nEasyStar.BOTTOM_LEFT = 'BOTTOM_LEFT';\nEasyStar.LEFT = 'LEFT';\nEasyStar.TOP_LEFT = 'TOP_LEFT';\nvar easystarjs = require('easystarjs');\nvar easystar = new easystarjs.js();\nvar grid = [[0, 0, 1, 0, 0],\n    [0, 0, 1, 0, 0],\n    [0, 0, 1, 0, 0],\n    [0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0]];\neasystar.setGrid(grid);\neasystar.setAcceptableTiles([0]);\neasystar.findPath(0, 0, 4, 0, function (path) {\n    if (path === null) {\n        console.log(\"Path was not found.\");\n    }\n    else {\n        for (let i = 0; i < path.length; i++) {\n            console.log(`x = ${path[i].x} y = ${path[i].y}`);\n        }\n    }\n});\neasystar.calculate();\n"],"file":"Astar.js"}