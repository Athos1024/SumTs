{"version":3,"sources":["ScriptTs/Leetcode/00双指针.ts","ScriptTs/Leetcode/01贪心思想.ts","ScriptTs/Leetcode/02二分查找.ts","ScriptTs/Leetcode/03搜索.ts"],"names":[],"mappings":"AAAA,kBAAU,QAAQ,CAAC;CA0JlB;AC1JD,kBAAU,QAAQ,CAAC;CA0MlB;AC1MD,kBAAU,QAAQ,CAAC;CA6FlB;AC7FD,kBAAU,QAAQ,CAAC;CAyDlB","file":"Leetcode.d.ts","sourcesContent":["namespace Leetcode {\r\n    //在有序数组中找出两个数，使它们的和为 target。\r\n    class TwoSum {\r\n        public run() {\r\n            let input: number[] = [2, 7, 11, 15];\r\n            let target = 13;\r\n\r\n            let i = 0, j = input.length - 1;\r\n            while (i < j) {\r\n                let sum = input[i] + input[j]\r\n                if (target == sum) {\r\n                    return [i, j];\r\n                } else if (target > sum) {\r\n                    i++;\r\n                } else {\r\n                    j--\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // let t = new TwoSum();\r\n    // console.log(t.run());\r\n\r\n\r\n    //两数平方和\r\n    class SumOfSquare {\r\n        public run() {\r\n            let input = 5;\r\n            let i = 0, j = Math.floor(Math.sqrt(input));\r\n            while (i <= j) {\r\n                let target = i * i + j * j;\r\n                if (target == input) {\r\n                    return true;\r\n                } else if (target > input) {\r\n                    j--;\r\n                } else {\r\n                    i++;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // let s = new SumOfSquare();\r\n    // console.log(s.run());\r\n\r\n    //回文字符串\r\n    class validPalindrome {\r\n\r\n        run(): boolean {\r\n            let str = \"abcba\";\r\n            for (let i = 0, j = str.length - 1; i < j; i++, j--) {\r\n                if(str[i] != str[j]){\r\n                    return this.isPalindrome(str,i,j - 1) || this.isPalindrome(str,i + 1,j);\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n\r\n        private isPalindrome(s:string,i:number,j:number){\r\n            while(i < j){\r\n                if(s[i++] != s[j--]){\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n\r\n    // let v = new validPalindrome();\r\n    // console.log('run',v.run());\r\n     \r\n\r\n    //归并两个有序数组\r\n    class merge{\r\n        run(){\r\n            let num1 = [1,2,3,0,0,0],   m = 3,\r\n                num2 = [2,5,6],         n =3;\r\n            let index1 = m - 1,index2 = n -1;\r\n            let indexMerge = m + n - 1;\r\n            while(index2 >= 0){\r\n                if(index1 < 0){\r\n                    num1[indexMerge--] = num2[index2--];\r\n                }else if(index2 < 0){\r\n                    num1[indexMerge--] = num1[index1--];\r\n                }else if(num1[index1] > num2[index2]){\r\n                    num1[indexMerge--] = num1[index1--];\r\n                }else{\r\n                    num1[indexMerge--] = num2[index2--];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    class ListNode {\r\n        val: number\r\n        next: ListNode | null\r\n        constructor(val?: number, next?: ListNode | null) {\r\n            this.val = (val===undefined ? 0 : val)\r\n            this.next = (next===undefined ? null : next)\r\n        }\r\n    }\r\n\r\n\r\n    // 判断链表是否存在环 \r\n    class linked{\r\n        run(head:ListNode){\r\n            if(head == null){\r\n                return false;\r\n            }\r\n            \r\n            let l1:ListNode = head,l2 = head.next;\r\n            while(l1 != null && l2 != null && l2.next != null){\r\n                if(l1 == l2){\r\n                    return true;\r\n                }\r\n\r\n                l1 = l1.next;\r\n                l2 = l2.next.next;\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n\r\n    class logestWord{\r\n        run(){\r\n            let s = 'abpcplea',d=['ale','apple','monkey','plea'];\r\n            let word = \"\";\r\n            for(let i of d){\r\n                let l1 = word.length,l2 = i.length;\r\n                if(l1 > l2 || (l1 == l2 && word.localeCompare(i) < 0)){\r\n                    continue;\r\n                }\r\n\r\n                if(this.isSubstr(s,i)){\r\n                    word = i;\r\n                }\r\n            }\r\n            return word;\r\n        }\r\n\r\n        private isSubstr(s:string,target:string){\r\n            let i =0,j =0;\r\n            while(i < s.length && j < target.length){\r\n                if(s.charAt(i) == target.charAt(j)){\r\n                    j++\r\n                }\r\n                i++;\r\n            }\r\n            return j == target.length;\r\n        }\r\n    }\r\n \r\n}","namespace Leetcode {\r\n    // 分配饼干\r\n    class AssignCookies {\r\n        run() {\r\n            let grid = [1, 3];\r\n            let size = [1, 2, 3];\r\n            if (grid == null || size == null) return 0;\r\n            grid.sort((a, b) => { return a - b });\r\n            size.sort((a, b) => { return a - b });\r\n            let gi = 0, si = 0;\r\n            while (gi < grid.length && si < size.length) {\r\n                if (grid[gi] <= size[si]) {\r\n                    gi++;\r\n                }\r\n                si++;\r\n            }\r\n            return gi;\r\n        }\r\n    }\r\n\r\n    //不重叠的区间个数\r\n    class NonOverlapping {\r\n        run() {\r\n            let intervals = [[1, 2], [1, 2], [1, 2]];\r\n            if (intervals.length == 0) {\r\n                return 0;\r\n            }\r\n            intervals.sort((a, b) => a[1] - b[1]);\r\n            let count = 0;\r\n            for (let i = 0; i < intervals.length - 1; i++) {\r\n                const [a, b] = intervals[i];\r\n                const [c, d] = intervals[i + 1];\r\n                if (b > c) {\r\n                    count++;\r\n                    intervals.splice(i + 1, 1);\r\n                    i--;\r\n                }\r\n            }\r\n            return count;\r\n        }\r\n    }\r\n\r\n    //投飞镖刺破气球\r\n    class Mininum {\r\n        run() {\r\n            let points: number[][] = [[10, 16], [2, 8], [1, 6], [7, 12]];\r\n            if (!points.length) return 0;\r\n            points.sort((a, b) => a[1] - b[1]);\r\n            let count = 1;\r\n            let right = points[0][1];\r\n            for (let i = 1; i < points.length; i++) {\r\n                if (right < points[i][0]) {\r\n                    count++;\r\n                    right = points[i][1]\r\n                }\r\n            }\r\n            return count;\r\n        }\r\n    }\r\n\r\n    class reconstruct {\r\n        run() {\r\n            let people: number[][] = [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]];\r\n            const len = people.length;\r\n            people.sort((a, b) => {\r\n                if (a[0] === b[0]) {\r\n                    return a[1] - b[1];\r\n                } else {\r\n                    return b[0] - b[0];\r\n                }\r\n            })\r\n\r\n            let res: typeof people = [];\r\n\r\n\r\n        }\r\n    }\r\n\r\n    function reconstructQueue(people: number[][]): number[][] {\r\n        const len = people.length;\r\n\r\n        // 按照身高降序\r\n        // 升高一样，按位置升序\r\n        people.sort((a, b) => {\r\n            if (a[0] === b[0]) {\r\n                return a[1] - b[1];\r\n            } else {\r\n                return b[0] - a[0];\r\n            }\r\n        });\r\n\r\n        let res: typeof people = [];\r\n        for (const item of people) {\r\n            // 对于item[1]与length的比较\r\n            // 1. item[1] > length，说明排在这之后，直接添加末尾\r\n            // 2. item[1] = length，如上，说明刚好在这个位置\r\n            // item[1] 的排序是升序排序，能保证其相同 itme[0] 的顺序\r\n            if (res.length <= item[1]) {\r\n                res.push(item)\r\n            } else {\r\n\r\n                // 3. item[1] < length，比如 res=[[7,0]], item=[5,0],此时插入到 item[1] 的位置\r\n                // 即使后面存在 item[1] 与前面相等，直接插入其前面就行了，\r\n                // 因为整个序列是从大到小排序，此时的 item[0] 是小于 res 中所有所有的值的，插入后符合结果\r\n                // 所以整个序列要从大到小排序。\r\n                res.splice(item[1], 0, item);\r\n            }\r\n        }\r\n\r\n        return res;\r\n    };\r\n\r\n    function swap(arr: any[], i: number, j: number) {\r\n        let temp = arr[i];\r\n        arr[i] = arr[j];\r\n        arr[j] = temp;\r\n    }\r\n\r\n    //买卖股票的最大收益\r\n    class best {\r\n        run() {\r\n            let prices = [7, 1, 5, 3, 6, 4];\r\n            let n = prices.length;\r\n            if(n == 0) return 0;\r\n            let soFarmin = prices[0];\r\n            let max = 0;\r\n            for (let i = 0; i < prices.length; i++) {\r\n                if(soFarmin > prices[i]){\r\n                    soFarmin = prices[i]\r\n                }else{\r\n                    max = Math.max(max,prices[i] - soFarmin);\r\n                }                \r\n            }\r\n            return max;\r\n        }\r\n\r\n        run2(){\r\n            let prices = [7, 1, 5, 3, 6, 4];\r\n            let profit = 0;\r\n            for(let i = 1;i<prices.length;i++){\r\n                if(prices[i] > prices[i -1]){\r\n                    profit += prices[i] - prices[i - 1];\r\n                }\r\n            }\r\n            return profit;\r\n        }\r\n    }\r\n\r\n    //判断是否为子序列\r\n    class Subsequence{\r\n        run(){\r\n            let s = \"abc\";\r\n            let t = \"ahbgdc\";\r\n            let index = -1;\r\n            for (let i = 0; i < s.length; i++) {\r\n                const element = s[i];\r\n                index = t.indexOf(element,i + 1);\r\n                if(index == -1){\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n\r\n    //修改一个数成为非递减数组\r\n    class decreasing{\r\n        run(){\r\n            let nums = [5,5,6,6];\r\n            let cnt = 0;\r\n            for (let i = 1; i < nums.length && cnt < 2; i++) {\r\n                if(nums[i] >= nums[i - 1]){\r\n                    continue;\r\n                }\r\n                cnt++;\r\n                if(i - 2 >= 0 && nums[i - 2]>nums[i]){\r\n                    nums[i] = nums[i -1];\r\n                }else{\r\n                    nums[i - 1] = nums[i];\r\n                }\r\n            }\r\n            return cnt <= 1;\r\n        }\r\n    }\r\n\r\n     class Maximum{\r\n        run(){\r\n            let nums =  [-2,1,-3,4,-1,2,1,-5,4];\r\n            let prevMaxSum = 0\r\n            let [maxSum] = nums\r\n          \r\n            nums.forEach(num => {\r\n              prevMaxSum = Math.max(prevMaxSum + num, num)\r\n              maxSum = Math.max(prevMaxSum, maxSum)\r\n            })\r\n          \r\n            return maxSum\r\n        }\r\n    }\r\n\r\n    let m = new Maximum();\r\n    // console.log('m.run',m.run());\r\n}\r\n","namespace Leetcode {\r\n    class tow {\r\n        run() {\r\n            let nums = [1, 2, 3, 4, 5, 6];\r\n            let key = 3;\r\n            let l = 0;\r\n            let h = nums.length - 1;\r\n            while (l <= h) {\r\n                let m: number = l + (h - l) / 2;\r\n                if (nums[m] == key) {\r\n                    return m;\r\n                } else if (nums[m] > key) {\r\n                    h = m - 1;\r\n                } else {\r\n                    l = m + 1;\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        run2() {\r\n            let nums = [1, 2, 3, 4, 5, 6];\r\n            let key = 3;\r\n            let l = 0, h = nums.length;\r\n            while (l < h) {\r\n                let m = Math.floor(l + (h - l) / 2);\r\n                if (nums[m] >= key) {\r\n                    h = m;\r\n                } else {\r\n                    l = m + 1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    class sqrt {\r\n        run() {\r\n            let x = 10;\r\n            if (x <= 1) {\r\n                return x;\r\n            }\r\n\r\n            let l = 1, h = x;\r\n            while (l <= h) {\r\n                let mid = Math.floor(l + (h - l) / 2);\r\n                let sqrt = x / mid;\r\n                if (sqrt == mid) {\r\n                    return mid;\r\n                } else if (mid > sqrt) {\r\n                    h = mid - 1;\r\n                } else {\r\n                    l = mid + 1;\r\n                }\r\n\r\n            }\r\n            return h;\r\n        }\r\n    }\r\n\r\n    class Find {\r\n        run() {\r\n            let nums:number[] =[];\r\n\r\n            // 思路：二分, \r\n            // 1.保证这个数的+1/-1都不相同\r\n            // 2.两次的话，当前的 [i]%2 === 0 && [i+1]%2 == 1 且 [i] === [i+1]\r\n            let left = 0\r\n            let right = nums.length\r\n            let L\r\n            let R\r\n            while (left <= right) {\r\n                let mid = left + right >> 1\r\n                if (nums[mid] === nums[mid + 1]) {\r\n                    L = mid\r\n                    R = mid + 1\r\n                } else if (nums[mid] === nums[mid - 1]) {\r\n                    L = mid - 1\r\n                    R = mid\r\n                } else {\r\n                    return nums[mid]\r\n                }\r\n                if (L % 2 === 0 && R % 2 == 1) {\r\n                    // 正常 向right\r\n                    left = mid + 1\r\n                } else {\r\n                    right = mid - 1\r\n                }\r\n            }\r\n\r\n            let f = new Find();\r\n            // console.log('f.run();', f.run());\r\n        }\r\n    }\r\n}","namespace Leetcode {\r\n\r\n    interface Point {\r\n        x: number;\r\n        y: number;\r\n    }\r\n    function shortestPathBinaryMatrix(grid: number[][]): number {\r\n        const queue = [];\r\n        const size = grid.length;\r\n        let res = 0;\r\n        const dirArr = [[0, 1], [1, 0], [0, -1], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]];\r\n        if (grid[0][0] === 1 || grid[size - 1][size - 1] === 1) {\r\n            return -1;\r\n        }\r\n        queue.push({x: 0, y: 0})\r\n        while (queue.length > 0) {\r\n            const len = queue.length;\r\n            for (let i = 0; i < len; i++) {\r\n                let curNode = queue[0];\r\n                if (curNode.x === size - 1 && curNode.y === size - 1) {\r\n                    return res + 1;\r\n                }\r\n                for (const dir of dirArr) {\r\n                    let gp: Point = {\r\n                        x: curNode.x + dir[0],\r\n                        y: curNode.y + dir[1]\r\n                    }\r\n                    if (gp.x < 0 || gp.x >= size || gp.y < 0 || gp.y >= size) {\r\n                        continue;\r\n                    }\r\n                    if (grid[gp.x][gp.y] === 1) {\r\n                        continue;\r\n                    }\r\n                    queue.push(gp);\r\n                    // 由于grid[x][y] = 1代表不通过，所以可以不需要额外空间来保存遍历过的位置\r\n                    grid[gp.x][gp.y] = 1;\r\n                }\r\n                queue.shift()\r\n            }\r\n            res++;\r\n        }\r\n        return -1;\r\n    \r\n    \r\n    };\r\n    \r\n    \r\n    console.log('',shortestPathBinaryMatrix([[1,1,0,1],\r\n        [1,0,1,0],\r\n        [1,1,1,1],\r\n        [1,0,1,1]]));\r\n    \r\n    \r\n    \r\n     \r\n    \r\n    \r\n}\r\n"]}