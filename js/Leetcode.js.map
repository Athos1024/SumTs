{"version":3,"names":[],"mappings":"","sources":["Leetcode.js"],"sourcesContent":["var Leetcode;\n(function (Leetcode) {\n    //在有序数组中找出两个数，使它们的和为 target。\n    class TwoSum {\n        run() {\n            let input = [2, 7, 11, 15];\n            let target = 13;\n            let i = 0, j = input.length - 1;\n            while (i < j) {\n                let sum = input[i] + input[j];\n                if (target == sum) {\n                    return [i, j];\n                }\n                else if (target > sum) {\n                    i++;\n                }\n                else {\n                    j--;\n                }\n            }\n        }\n    }\n    // let t = new TwoSum();\n    // console.log(t.run());\n    //两数平方和\n    class SumOfSquare {\n        run() {\n            let input = 5;\n            let i = 0, j = Math.floor(Math.sqrt(input));\n            while (i <= j) {\n                let target = i * i + j * j;\n                if (target == input) {\n                    return true;\n                }\n                else if (target > input) {\n                    j--;\n                }\n                else {\n                    i++;\n                }\n            }\n            return false;\n        }\n    }\n    // let s = new SumOfSquare();\n    // console.log(s.run());\n    //回文字符串\n    class validPalindrome {\n        run() {\n            let str = \"abcba\";\n            for (let i = 0, j = str.length - 1; i < j; i++, j--) {\n                if (str[i] != str[j]) {\n                    return this.isPalindrome(str, i, j - 1) || this.isPalindrome(str, i + 1, j);\n                }\n            }\n            return true;\n        }\n        isPalindrome(s, i, j) {\n            while (i < j) {\n                if (s[i++] != s[j--]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    // let v = new validPalindrome();\n    // console.log('run',v.run());\n    //归并两个有序数组\n    class merge {\n        run() {\n            let num1 = [1, 2, 3, 0, 0, 0], m = 3, num2 = [2, 5, 6], n = 3;\n            let index1 = m - 1, index2 = n - 1;\n            let indexMerge = m + n - 1;\n            while (index2 >= 0) {\n                if (index1 < 0) {\n                    num1[indexMerge--] = num2[index2--];\n                }\n                else if (index2 < 0) {\n                    num1[indexMerge--] = num1[index1--];\n                }\n                else if (num1[index1] > num2[index2]) {\n                    num1[indexMerge--] = num1[index1--];\n                }\n                else {\n                    num1[indexMerge--] = num2[index2--];\n                }\n            }\n        }\n    }\n    class ListNode {\n        constructor(val, next) {\n            this.val = (val === undefined ? 0 : val);\n            this.next = (next === undefined ? null : next);\n        }\n    }\n    // 判断链表是否存在环 \n    class linked {\n        run(head) {\n            if (head == null) {\n                return false;\n            }\n            let l1 = head, l2 = head.next;\n            while (l1 != null && l2 != null && l2.next != null) {\n                if (l1 == l2) {\n                    return true;\n                }\n                l1 = l1.next;\n                l2 = l2.next.next;\n            }\n            return true;\n        }\n    }\n    class logestWord {\n        run() {\n            let s = 'abpcplea', d = ['ale', 'apple', 'monkey', 'plea'];\n            let word = \"\";\n            for (let i of d) {\n                let l1 = word.length, l2 = i.length;\n                if (l1 > l2 || (l1 == l2 && word.localeCompare(i) < 0)) {\n                    continue;\n                }\n                if (this.isSubstr(s, i)) {\n                    word = i;\n                }\n            }\n            return word;\n        }\n        isSubstr(s, target) {\n            let i = 0, j = 0;\n            while (i < s.length && j < target.length) {\n                if (s.charAt(i) == target.charAt(j)) {\n                    j++;\n                }\n                i++;\n            }\n            return j == target.length;\n        }\n    }\n})(Leetcode || (Leetcode = {}));\nvar Leetcode;\n(function (Leetcode) {\n    // 分配饼干\n    class AssignCookies {\n        run() {\n            let grid = [1, 3];\n            let size = [1, 2, 3];\n            if (grid == null || size == null)\n                return 0;\n            grid.sort((a, b) => { return a - b; });\n            size.sort((a, b) => { return a - b; });\n            let gi = 0, si = 0;\n            while (gi < grid.length && si < size.length) {\n                if (grid[gi] <= size[si]) {\n                    gi++;\n                }\n                si++;\n            }\n            return gi;\n        }\n    }\n    //不重叠的区间个数\n    class NonOverlapping {\n        run() {\n            let intervals = [[1, 2], [1, 2], [1, 2]];\n            if (intervals.length == 0) {\n                return 0;\n            }\n            intervals.sort((a, b) => a[1] - b[1]);\n            let count = 0;\n            for (let i = 0; i < intervals.length - 1; i++) {\n                const [a, b] = intervals[i];\n                const [c, d] = intervals[i + 1];\n                if (b > c) {\n                    count++;\n                    intervals.splice(i + 1, 1);\n                    i--;\n                }\n            }\n            return count;\n        }\n    }\n    //投飞镖刺破气球\n    class Mininum {\n        run() {\n            let points = [[10, 16], [2, 8], [1, 6], [7, 12]];\n            if (!points.length)\n                return 0;\n            points.sort((a, b) => a[1] - b[1]);\n            let count = 1;\n            let right = points[0][1];\n            for (let i = 1; i < points.length; i++) {\n                if (right < points[i][0]) {\n                    count++;\n                    right = points[i][1];\n                }\n            }\n            return count;\n        }\n    }\n    class reconstruct {\n        run() {\n            let people = [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]];\n            const len = people.length;\n            people.sort((a, b) => {\n                if (a[0] === b[0]) {\n                    return a[1] - b[1];\n                }\n                else {\n                    return b[0] - b[0];\n                }\n            });\n            let res = [];\n        }\n    }\n    function reconstructQueue(people) {\n        const len = people.length;\n        // 按照身高降序\n        // 升高一样，按位置升序\n        people.sort((a, b) => {\n            if (a[0] === b[0]) {\n                return a[1] - b[1];\n            }\n            else {\n                return b[0] - a[0];\n            }\n        });\n        let res = [];\n        for (const item of people) {\n            // 对于item[1]与length的比较\n            // 1. item[1] > length，说明排在这之后，直接添加末尾\n            // 2. item[1] = length，如上，说明刚好在这个位置\n            // item[1] 的排序是升序排序，能保证其相同 itme[0] 的顺序\n            if (res.length <= item[1]) {\n                res.push(item);\n            }\n            else {\n                // 3. item[1] < length，比如 res=[[7,0]], item=[5,0],此时插入到 item[1] 的位置\n                // 即使后面存在 item[1] 与前面相等，直接插入其前面就行了，\n                // 因为整个序列是从大到小排序，此时的 item[0] 是小于 res 中所有所有的值的，插入后符合结果\n                // 所以整个序列要从大到小排序。\n                res.splice(item[1], 0, item);\n            }\n        }\n        return res;\n    }\n    ;\n    function swap(arr, i, j) {\n        let temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n    //买卖股票的最大收益\n    class best {\n        run() {\n            let prices = [7, 1, 5, 3, 6, 4];\n            let n = prices.length;\n            if (n == 0)\n                return 0;\n            let soFarmin = prices[0];\n            let max = 0;\n            for (let i = 0; i < prices.length; i++) {\n                if (soFarmin > prices[i]) {\n                    soFarmin = prices[i];\n                }\n                else {\n                    max = Math.max(max, prices[i] - soFarmin);\n                }\n            }\n            return max;\n        }\n        run2() {\n            let prices = [7, 1, 5, 3, 6, 4];\n            let profit = 0;\n            for (let i = 1; i < prices.length; i++) {\n                if (prices[i] > prices[i - 1]) {\n                    profit += prices[i] - prices[i - 1];\n                }\n            }\n            return profit;\n        }\n    }\n    //判断是否为子序列\n    class Subsequence {\n        run() {\n            let s = \"abc\";\n            let t = \"ahbgdc\";\n            let index = -1;\n            for (let i = 0; i < s.length; i++) {\n                const element = s[i];\n                index = t.indexOf(element, i + 1);\n                if (index == -1) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    //修改一个数成为非递减数组\n    class decreasing {\n        run() {\n            let nums = [5, 5, 6, 6];\n            let cnt = 0;\n            for (let i = 1; i < nums.length && cnt < 2; i++) {\n                if (nums[i] >= nums[i - 1]) {\n                    continue;\n                }\n                cnt++;\n                if (i - 2 >= 0 && nums[i - 2] > nums[i]) {\n                    nums[i] = nums[i - 1];\n                }\n                else {\n                    nums[i - 1] = nums[i];\n                }\n            }\n            return cnt <= 1;\n        }\n    }\n    class Maximum {\n        run() {\n            let nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4];\n            let prevMaxSum = 0;\n            let [maxSum] = nums;\n            console.log(maxSum);\n            nums.forEach(num => {\n                prevMaxSum = Math.max(prevMaxSum + num, num);\n                maxSum = Math.max(prevMaxSum, maxSum);\n            });\n            return maxSum;\n        }\n    }\n    let m = new Maximum();\n    console.log('m.run', m.run());\n})(Leetcode || (Leetcode = {}));\n"],"file":"Leetcode.js"}