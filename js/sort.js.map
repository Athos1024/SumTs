{"version":3,"names":[],"mappings":"","sources":["sort.js"],"sourcesContent":["console.log('gulp1');\nconsole.log('gulp2');\nvar Test;\n(function (Test) {\n    console.log('hello world');\n    console.log('hello world');\n    console.log('hello world');\n    function minCoinChange(coins, amount) {\n        let f = [];\n        let temp = [];\n        f[0] = 0;\n        for (let i = 1; i <= amount; i++) {\n            coins.forEach((coin) => {\n                if (i - coin < 0) {\n                    temp.push(Number.MAX_SAFE_INTEGER);\n                }\n                else {\n                    temp.push(f[i - coin] + 1);\n                }\n            });\n            let min = Math.min(...temp);\n            f[i] = min;\n            temp = [];\n        }\n        return f[amount] == Number.MAX_SAFE_INTEGER ? -1 : f[amount];\n    }\n    // console.log(minCoinChange([3, 8, 10, 25], 6));\n    // 用字符串返回一个键盘图形\n    // // 最少硬币找零 - 贪心算法\n    // function MinCoinChange1(coins) {\n    //   return function (amount) {\n    //     let total = 0, change = []\n    //     for (let i = coins.length; i >= 0; i--) {\n    //       let coin = coins[i]\n    //       while (total + coin <= amount) {\n    //         change.push(coin)\n    //         total += coin\n    //       }\n    //     }\n    //     return change\n    //   }\n    // }\n    // let f = MinCoinChange1([2,3,7,10]);\n    // console.log(f(8));\n    let arr = [3, 5, 7, 10];\n    let num = 7;\n    function min(coins, money) {\n        for (let i = arr.length - 1; i >= 0; i--) {\n            const element = arr[i];\n            if (element > money) {\n                //面值比需要找的零钱多\n                continue;\n            }\n            let j = i;\n            let tmp = money;\n            let result = [];\n            while (j >= 0) {\n                if (tmp - arr[j] >= 0) {\n                    tmp -= arr[j];\n                    result.push(arr[j]);\n                    if (tmp == 0) {\n                        //满足条件\n                        return result;\n                    }\n                }\n                else {\n                    j--;\n                }\n            }\n        }\n        return -1;\n    }\n    console.log(min(arr, num));\n})(Test || (Test = {}));\nvar structure;\n(function (structure) {\n    class Stack00 {\n        constructor() {\n            this.list = [];\n        }\n        push(element) {\n            return this.list.push(element);\n        }\n        pop() {\n            return this.list.pop();\n        }\n        isEmpty() {\n            return !!this.list.length;\n        }\n        size() {\n            return this.list.length;\n        }\n        peek() {\n            return this.list[this.list.length - 1];\n        }\n        clear() {\n            this.list = [];\n        }\n        toString() {\n            return this.list.toString();\n        }\n    }\n    class Stack01 {\n        constructor() {\n            this.map = {};\n            this.count = 0;\n        }\n        push(element) {\n            this.map[this.count] = element;\n            this.count++;\n            return this.count;\n        }\n        pop() {\n            let element = this.map[this.count - 1];\n            this.map[this.count - 1] = null;\n            this.count--;\n            return element;\n        }\n        peek() {\n            return this.map[this.count - 1];\n        }\n        size() {\n            return this.count;\n        }\n        isEmpty() {\n            return !this.count;\n        }\n        clear() {\n            this.count = 0;\n            this.map = {};\n        }\n        toString() {\n            if (this.isEmpty())\n                return \"\";\n            let str = \"\";\n            for (let i in this.map) {\n                str += this.map[i];\n            }\n        }\n    }\n    let stack = new Stack00();\n    // stack.push(1);\n    // stack.push(5);\n    // stack.push(3);\n    // console.log(stack.pop());\n    // console.log(stack.toString());\n})(structure || (structure = {}));\nvar structure;\n(function (structure) {\n    class Queue {\n        constructor() {\n            this.count = 0;\n            this.lastCount = 0;\n            this.map = {};\n        }\n        enqueue(...element) {\n            if (element.length == 1) {\n                this.map[this.lastCount] = element[0];\n                this.lastCount++;\n            }\n            else {\n                element.forEach((e) => this.enqueue(e));\n            }\n        }\n        dequeue() {\n            if (this.isEmpty())\n                return undefined;\n            let element = this.map[this.count];\n            delete this.map[this.count];\n            this.count++;\n            return element;\n        }\n        isEmpty() {\n            return !(this.lastCount - this.count);\n        }\n        size() {\n            return this.lastCount - this.count;\n        }\n        peek() {\n            return this.map[this.count];\n        }\n        clear() {\n            this.count = this.lastCount = 0;\n            this.map = {};\n        }\n        toString() {\n            if (this.isEmpty())\n                return \"\";\n            let str = \"\";\n            for (let i in this.map) {\n                str += \"-\" + this.map[i];\n            }\n            return str;\n        }\n    }\n    class Deque {\n        constructor() {\n            this.count = 0;\n            this.lastCount = 0;\n            this.map = {};\n        }\n        addFront(...element) {\n            if (!element.length)\n                return;\n            if (element.length > 1) {\n                for (let i = 0; i < element.length; i++) {\n                    this.addFront(element[i]);\n                }\n                return;\n            }\n            let item = element[0];\n            if (this.count > 0) {\n                this.count--;\n                this.map[this.count] = item;\n            }\n            else {\n                for (let i = this.lastCount; i > 0; i--) {\n                    this.map[i] = this.map[i - 1];\n                }\n                this.lastCount++;\n                this.map[this.count] = item;\n            }\n        }\n        addBack(...element) {\n            if (element.length > 1) {\n                for (let i = 0; i < element.length; i++) {\n                    this.addBack(element[i]);\n                }\n            }\n            else {\n                this.map[this.lastCount++] = element[0];\n            }\n        }\n        removeFront() {\n            let element = this.map[this.count];\n            delete this.map[this.count];\n            this.count++;\n            return element;\n        }\n        removeBack() {\n            let element = this.map[this.lastCount - 1];\n            delete this.map[this.lastCount - 1];\n            this.lastCount--;\n            return element;\n        }\n        peekFront() {\n            return this.map[this.count];\n        }\n        peekBack() {\n            return this.map[this.lastCount - 1];\n        }\n        isEmpty() {\n            return !(this.lastCount - this.count);\n        }\n        size() {\n            return this.lastCount - this.count;\n        }\n        claer() {\n            this.lastCount = this.count = 0;\n            this.map = {};\n        }\n        toString() {\n            if (this.isEmpty())\n                return \"\";\n            let str = \"\";\n            for (let i in this.map) {\n                str += \"-\" + this.map[i];\n            }\n            return str;\n        }\n    }\n})(structure || (structure = {}));\nvar structure;\n(function (structure) {\n    class Node {\n        constructor(element) {\n            this.element = element;\n            this.next = null;\n        }\n    }\n    structure.Node = Node;\n    class DoublyNode {\n        constructor(element) {\n            this.element = element;\n            this.prev = null;\n            this.next = null;\n        }\n    }\n    structure.DoublyNode = DoublyNode;\n    function defaultEquals(a, b) {\n        return a === b;\n    }\n    structure.defaultEquals = defaultEquals;\n    class TreeNode {\n        constructor(element) {\n            this.key = element;\n            this.right = null;\n            this.left = null;\n        }\n    }\n    structure.TreeNode = TreeNode;\n    class RBNode extends TreeNode {\n        constructor(element) {\n            super(element);\n            this.parent = null;\n            this.color = 0 /* Red */;\n        }\n        isRed() {\n            return this.color == 0 /* Red */;\n        }\n    }\n    structure.RBNode = RBNode;\n})(structure || (structure = {}));\n/// <reference path=\"./utility/Node.ts\" />\nvar structure;\n(function (structure) {\n    class LinkedList {\n        constructor() {\n            this.count = 0;\n            this.head = null;\n            this.equalsFn = structure.defaultEquals;\n        }\n        push(element) {\n            const node = new structure.Node(element);\n            if (this.head == null) {\n                this.head = node;\n            }\n            else {\n                let current = this.head;\n                while (current.next) {\n                    current = current.next;\n                }\n                current.next = node;\n            }\n            this.count++;\n        }\n        insert(element, index) {\n            if (index < 0 || index > this.count)\n                return false;\n            let node = new structure.Node(element);\n            let head = this.head;\n            if (index == 0) {\n                this.head = node;\n                node.next = head;\n            }\n            else {\n                let previous = this.getElementAt(index - 1);\n                let nextNode = previous.next;\n                previous.next = node;\n                node.next = nextNode;\n            }\n            this.count++;\n            return true;\n        }\n        getElementAt(index) {\n            if (index < 0 || index >= this.count)\n                return undefined;\n            let current = this.head;\n            for (let i = 0; i < index; i++) {\n                current = current.next;\n            }\n            return current;\n        }\n        indexof(element) {\n            let node = this.head;\n            let exist = false;\n            let index = 0;\n            while (node) {\n                if (this.equalsFn(node.element, element)) {\n                    exist = true;\n                    break;\n                }\n                node = node.next;\n                index++;\n            }\n            return exist ? index : -1;\n        }\n        removeAt(index) {\n            if (index < 0 || index > this.count)\n                return false;\n            let node = this.head;\n            if (index == 0) {\n                this.head = node.next;\n            }\n            else {\n                let previous = this.getElementAt(index - 1);\n                node = previous.next;\n                previous.next = node.next;\n            }\n            this.count--;\n            return node.element;\n        }\n        remove(element) {\n            let index = this.indexof(element);\n            return index === -1 ? null : this.removeAt(index);\n        }\n        isEmpty() {\n            return this.count === 0;\n        }\n        size() {\n            return this.count;\n        }\n        getHead() {\n            return this.head;\n        }\n        clear() {\n            this.head = null;\n            this.count = 0;\n        }\n        toString() {\n            let res = '';\n            let current = this.head;\n            while (current) {\n                res += \"-\" + current.element;\n                current = current.next;\n            }\n            return res;\n        }\n    }\n    class DoublyLikedList {\n        constructor() {\n            this.count = 0;\n            this.head = null;\n            this.tail = null;\n        }\n        push(element) {\n            const node = new structure.DoublyNode(element);\n            if (this.isEmpty()) {\n                this.head = this.tail = node;\n            }\n            else {\n                let cur = this.tail;\n                cur.next = node;\n                node.prev = cur;\n                this.tail = node;\n            }\n            this.count++;\n        }\n        install(element, index) {\n            if (index < 0 || index > this.count)\n                return false;\n            const node = new structure.DoublyNode(element);\n            let current = this.head;\n            if (index == 0) {\n                if (this.isEmpty()) {\n                    this.head = this.tail = node;\n                }\n                else {\n                    node.next = current;\n                    current.prev = node;\n                    this.head = node;\n                }\n            }\n            else if (index == this.count) {\n                let cur = this.tail;\n                cur.next = node;\n                node.prev = cur;\n                this.tail = node;\n            }\n            else {\n                let prev = this.getElement(index - 1);\n                node.next = prev.next;\n                node.next.prev = node;\n                node.prev = prev;\n                prev.next = node;\n            }\n            this.count++;\n            return true;\n        }\n        removeAt(index) {\n            if (index < 0 || index > this.count)\n                return null;\n            let current = this.head;\n            if (index == 0) {\n                if (this.size() === 1) {\n                    this.head = this.tail = null;\n                }\n                else {\n                    let next = current.next;\n                    next.prev = null;\n                    this.head = next;\n                }\n            }\n            else if (index === this.count) {\n                let cur = this.tail;\n                let prev = cur.prev;\n                prev.next = null;\n                this.tail = prev;\n            }\n            else {\n                let prev = this.getElement(index - 1);\n                let next = prev.next;\n                prev.next = next.next;\n                next.prev.next = prev;\n            }\n            this.count--;\n        }\n        getElement(index) {\n            if (index < 0 || index > this.count)\n                return null;\n            let node = this.head;\n            for (let i = 0; i < index; i++) {\n                node = node.next;\n            }\n            return node;\n        }\n        clear() {\n            this.count = 0;\n            this.head = null;\n            this.tail = null;\n        }\n        isEmpty() {\n            return this.count == 0;\n        }\n        size() {\n            return this.count;\n        }\n        getHead() {\n            return this.head;\n        }\n        getTail() {\n            return this.tail;\n        }\n        toString() {\n            if (this.isEmpty())\n                return \"\";\n            let str = \"\";\n            let cur = this.head;\n            for (let i = 0; i < this.count; i++) {\n                str += \"-\" + cur.element;\n                cur = cur.next;\n            }\n            return str;\n        }\n    }\n})(structure || (structure = {}));\nvar structure;\n(function (structure) {\n    class mySet {\n        constructor() {\n            this.items = {};\n        }\n        add(element) {\n            if (this.has(element))\n                return false;\n            this.items[element + \"\"] = element;\n            return true;\n        }\n        delete(element) {\n            if (!this.has(element))\n                return false;\n            delete this.items[element + \"\"];\n            return true;\n        }\n        clear() {\n            this.items = {};\n        }\n        size() {\n            return Object.keys(this.items).length;\n        }\n        value() {\n            let arr = [];\n            for (let key in this.items) {\n                arr.push(this.items[key]);\n            }\n            return arr;\n        }\n        getUniot(otherSet) {\n            const union = new mySet();\n            this.value().forEach(el => union.add(el));\n            otherSet.value().forEach(el => union.add(el));\n            return union;\n        }\n        getIntersection(otherSet) {\n            const intersection = new mySet();\n            let smallerSet = this.value();\n            let biggerSet = this.value();\n            if (smallerSet.length > biggerSet.length) {\n                [smallerSet, biggerSet] = [biggerSet, smallerSet];\n            }\n            smallerSet.forEach(el => {\n                for (let i = 0; i < biggerSet.length; i++) {\n                    let element = biggerSet[i];\n                    if (el == element) {\n                        intersection.add(el);\n                        break;\n                    }\n                }\n            });\n            return intersection;\n        }\n        getDifference(otherSet) {\n            const difference = new mySet();\n            this.value().forEach(el => {\n                if (!otherSet.has(el)) {\n                    difference.add(el);\n                }\n            });\n            return difference;\n        }\n        has(element) {\n            return Object.prototype.hasOwnProperty.call(this.items, element + \"\");\n        }\n    }\n})(structure || (structure = {}));\nvar structure;\n(function (structure) {\n    function factorialIterative(n) {\n        if (n === 1 || n === 0) {\n            //出口\n            return 1;\n        }\n        return n * factorialIterative(n - 1); //入口\n    }\n    function getFibonaci(n) {\n        if (n < 1)\n            return 0;\n        if (n < 2)\n            return 1;\n        return getFibonaci(n - 1) + getFibonaci(n - 2);\n    }\n    function fibonaciMeno(n) {\n        let mone = [1, 1];\n        const fibonaci = (n) => {\n            if (mone[n]) {\n                return mone[n];\n            }\n            return (mone[n] = fibonaci(n - 1) + fibonaci(n - 2));\n        };\n        return fibonaci(n);\n    }\n})(structure || (structure = {}));\nvar structure;\n(function (structure) {\n    let arr = [2, 3, 1, 3, 1];\n    function horner(arr, x) {\n        let res = 0;\n        for (let i = 0; i < arr.length; i++) {\n            res += x * res + res[i];\n        }\n        return res;\n    }\n    function hashFunc(str, size) {\n        let hashCode = 0;\n        for (let i = 0; i < str.length; i++) {\n            hashCode = 37 * hashCode + str.charCodeAt(i);\n        }\n        let res = hashCode % 37;\n        return res;\n    }\n    class HashTable {\n        constructor(limit) {\n            this.limit = limit;\n            this.count = 0;\n            this.storage = [];\n        }\n        hashFunction(str, size) {\n            let hashCode = 0;\n            for (let i = 0; i < str.length; i++) {\n                hashCode += 37 * hashCode + str.charCodeAt(i);\n            }\n            let res = hashCode % size;\n            return res;\n        }\n        put(key, value) {\n            let index = this.hashFunction(key, this.limit);\n            let bucket = this.storage[index];\n            if (!bucket) {\n                this.storage[index] = [];\n                bucket = this.storage[index];\n            }\n            for (let i = 0; i < bucket.length; i++) {\n                let tuple = bucket[i];\n                if (tuple[0] === key) {\n                    return tuple[1] = value;\n                }\n            }\n            bucket.push([key, value]);\n            this.count += 1;\n            if (this.count > this.limit * 0.75) {\n                this.resize(this.getPrime(this.limit * 2));\n            }\n        }\n        get(key = \"\") {\n            let index = this.hashFunction(key, this.limit);\n            let bucket = this.storage[index];\n            if (!bucket)\n                return null;\n            for (let i = 0; i < bucket.length; i++) {\n                let tuple = bucket[i];\n                if (tuple[0] === key) {\n                    return tuple[1];\n                }\n            }\n            return null;\n        }\n        remove(key) {\n            let index = this.hashFunction(key, this.limit);\n            let bucket = this.storage[index];\n            if (!bucket)\n                return false;\n            for (let i = 0; i < bucket.length; i++) {\n                let tuple = bucket[i];\n                if (tuple[0] == key) {\n                    this.count--;\n                    delete bucket[i];\n                }\n                if (!bucket.entries().next().value[1])\n                    delete this.storage[index];\n                if (this.limit > 7 && this.count < this.limit * 0.25) {\n                    this.resize(this.isPrime(Math.floor(this.limit / 2)));\n                }\n                return true;\n            }\n            return false;\n        }\n        size() {\n            return this.count;\n        }\n        isEmpty() {\n            return !(this.count > 0);\n        }\n        resize(size) {\n            let oldStorage = this.storage;\n            this.storage = [];\n            this.count = 0;\n            this.limit = size;\n            for (let i = 0; i < oldStorage.length; i++) {\n                let bucket = oldStorage[i];\n                if (!bucket)\n                    continue;\n                for (let j = 0; j < bucket.length; j++) {\n                    let tuple = bucket[j];\n                    this.put(tuple[0], tuple[1]);\n                }\n            }\n        }\n        getPrime(num) {\n            while (!this.isPrime(num)) {\n                num++;\n            }\n            return num;\n        }\n        isPrime(num) {\n            if (num <= 0)\n                return false;\n            let newNum = ~~Math.sqrt(num);\n            for (let i = 2; i < newNum; i++) {\n                if (num % i == 0)\n                    return false;\n            }\n            return true;\n        }\n    }\n    function isPrimeNum01(num) {\n        if (num <= 0)\n            return false;\n        for (let i = 2; i < num; i++) {\n            if (num % i == 0)\n                return false;\n        }\n        return true;\n    }\n    function isPrimeNum02(num) {\n        if (num <= 0)\n            return false;\n        let numNum = ~~Math.sqrt(num);\n        for (let i = 0; i < numNum; i++) {\n            if (num % i == 0)\n                return false;\n        }\n        return true;\n    }\n})(structure || (structure = {}));\n/// <reference path=\"./utility/Node.ts\" />\nvar structure;\n(function (structure) {\n    class BinarySearchTree {\n        constructor() {\n            this.root = null;\n        }\n        /* 私有方法 */\n        insertNode(node, key) {\n            //插入操作实体函数\n            if (key > node.key) {\n                //在右边插入\n                if (node.right === null) {\n                    //如果左节点为空 插入 --出口\n                    node.right = new structure.TreeNode(key);\n                }\n                else {\n                    //否则进入递归  --入口\n                    this.insertNode(node.right, key);\n                }\n            }\n            else {\n                //在左边插入同理\n                if (node.left === null) {\n                    node.left = new structure.TreeNode(key);\n                }\n                else {\n                    this.insertNode(node.left, key);\n                }\n            }\n        }\n        preOrderTraverseNode(node, callback) {\n            //先序遍历实体函数\n            if (node != null) {\n                callback(node.key);\n                this.preOrderTraverseNode(node.left, callback);\n                this.preOrderTraverseNode(node.right, callback);\n            }\n        }\n        inOrderTraverseNode(node, callback) {\n            //中序遍历实体函数\n            if (node != null) {\n                this.inOrderTraverseNode(node.left, callback);\n                callback(node.key);\n                this.inOrderTraverseNode(node.right, callback);\n            }\n        }\n        postOrderTraverseNode(node, callback) {\n            //后序遍历实体函数\n            if (node !== null) {\n                this.postOrderTraverseNode(node.left, callback);\n                this.postOrderTraverseNode(node.right, callback);\n                callback(node.key);\n            }\n        }\n        getMinNode(node) {\n            //得到最小的节点\n            while (node !== null && node.left !== null) {\n                node = node.left;\n            }\n            return node;\n        }\n        getMaxNode(node) {\n            //得到最大的节点\n            while (node !== null && node.right !== null) {\n                node = node.right;\n            }\n            return node;\n        }\n        searchNode(node, key) {\n            //根据键值查找节点 递归版\n            if (node === null)\n                return false;\n            if (key > node.key)\n                return this.searchNode(node.right, key);\n            if (key < node.key)\n                return this.searchNode(node.left, key);\n            return true;\n        }\n        removeNode(node, key) {\n            if (node === null)\n                return null;\n            if (key === node.key) {\n                //执行删除\n                if (node.left === null || node.right === null) {\n                    //第二种情况,节点只有一个子节点\n                    node = node.right || node.left;\n                    return node;\n                }\n                else {\n                    //第三种情况 ,节点有两个子节点\n                    const aux = this.getMinNode(node.right);\n                    node.key = aux.key;\n                    node.right = this.removeNode(node.right, aux.key);\n                    return node;\n                }\n            }\n            else if (key > node.key) {\n                //指定的key较大 传入右节点递归\n                node.right = this.removeNode(node.right, key);\n                return node;\n            }\n            else if (key < node.key) {\n                //指定的key较小 传入左节点递归\n                node.left = this.removeNode(node.left, key);\n                return node;\n            }\n        }\n        /* 外部方法  */\n        insert(key) {\n            //向数中插入一个新的键\n            if (this.root === null) {\n                //如果树为空 直接插入\n                this.root = new structure.TreeNode(key);\n            }\n            else {\n                //否则交给 插入函数去处理\n                this.insertNode(this.root, key);\n            }\n        }\n        search(key) {\n            //在树中查找一个键。如果节点存在，则返回 true；如果不存在，则返回false\n            // ----递归版本\n            return this.searchNode(this.root, key);\n            // ----while循环版本 帮助理解\n            // let node = this.root\n            // while (node !== null) {\n            //   if (key > node.key) {\n            //     node = node.right\n            //   } else if (key < node.key) {\n            //     node = node.left\n            //   } else {\n            //     return true\n            //   }\n            // }\n            // return false\n        }\n        preOrderTraverse(callback) {\n            //先序遍历\n            this.preOrderTraverseNode(this.root, callback);\n        }\n        inOrderTraverse(callback) {\n            //中序遍历\n            this.inOrderTraverseNode(this.root, callback);\n        }\n        postOrderTraverse(callback) {\n            //后序遍历\n            this.postOrderTraverseNode(this.root, callback);\n        }\n        min() {\n            //返回数中最小的键\n            if (this.root === null)\n                return null;\n            return this.getMinNode(this.root).key;\n        }\n        max() {\n            //返回数中最大的键\n            if (this.root === null)\n                return null;\n            return this.getMaxNode(this.root).key;\n        }\n        remove(key) {\n            //从树中移除某个键\n            this.root = this.removeNode(this.root, key);\n        }\n    }\n    class RedBlackTree extends BinarySearchTree {\n        constructor() {\n            super();\n        }\n        insert(key) {\n            if (this.root == null) {\n                this.root = new structure.RBNode(key);\n                this.root.color = 1 /* Black */;\n            }\n            else {\n                const newNode = this.insertNode(this.root, key);\n                this.fixTreeProperties(newNode);\n            }\n        }\n        insertNode(node, key) {\n            if (key > node.key) {\n                if (node.right === null) {\n                    node.right = new structure.RBNode(key);\n                    node.right.parent = node;\n                }\n                else {\n                    return this.insertNode(node.right, key);\n                }\n            }\n            else {\n                if (node.left === null) {\n                    node.left = new structure.RBNode(key);\n                    node.left.parent = node;\n                }\n                else {\n                    return this.insertNode(node.left, key);\n                }\n            }\n        }\n        fixTreeProperties(node) {\n            while (node && node.parent && node.parent.isRed() && node.isRed()) {\n                let parnet = node.parent;\n                const grandParent = parnet.parent;\n                if (grandParent && grandParent.left == parnet) {\n                    //p =G.L\n                    const uncle = grandParent.right;\n                    if (uncle && uncle.isRed()) {\n                        grandParent.color = 0 /* Red */;\n                        parnet.color = 1 /* Black */;\n                        uncle.color = 1 /* Black */;\n                        node = grandParent;\n                    }\n                    else {\n                        if (node === parnet.right) {\n                            this.rotaionRR(parnet);\n                            node = parnet;\n                            parnet = node.parent;\n                        }\n                        this.rotaionLL(grandParent);\n                        parnet.color = 1 /* Black */;\n                        grandParent.color = 0 /* Red */;\n                        node.parent;\n                    }\n                }\n                else {\n                    const uncle = grandParent.left;\n                    if (uncle && uncle.isRed()) {\n                        grandParent.color = 0 /* Red */;\n                        uncle.color = 1 /* Black */;\n                        parnet.color = 1 /* Black */;\n                        node = grandParent;\n                    }\n                    else {\n                        if (node == parnet.left) {\n                            this.rotaionLL(parnet);\n                            node = parnet;\n                            parnet = grandParent;\n                        }\n                    }\n                    this.rotaionRR(grandParent);\n                    parnet.color = 1 /* Black */;\n                    grandParent.color = 0 /* Red */;\n                    node = parnet;\n                }\n            }\n        }\n        rotaionRR(node) {\n            const tmp = node.right;\n            node.right = tmp.left;\n            if (tmp.left && tmp.left.key) {\n                tmp.left.parent = node.right;\n            }\n            tmp.parent = node.parent;\n            if (!tmp.parent) {\n                this.root = tmp.parent;\n            }\n            else {\n                if (tmp.parent.left == node) {\n                    tmp.parent.left = tmp;\n                }\n                else {\n                    tmp.parent.right = tmp;\n                }\n            }\n            tmp.left = node;\n            node.parent = tmp;\n        }\n        rotaionLL(node) {\n            const tmp = node.left;\n            node.left = tmp.right;\n            if (tmp.right && tmp.right.key) {\n                tmp.right.parent = node;\n            }\n            tmp.parent = node.parent;\n            if (!tmp.parent) {\n                this.root = tmp.parent;\n            }\n            else {\n                if (tmp.parent.left == node) {\n                    tmp.parent.left = tmp;\n                }\n                else {\n                    tmp.parent.right = tmp;\n                }\n            }\n            tmp.left = node;\n            node.parent = tmp;\n        }\n    }\n})(structure || (structure = {}));\nvar structure;\n(function (structure) {\n    class MinHeap {\n        constructor() {\n            this.heap = [];\n        }\n        getLeftIndex(index) {\n            return index * 2 + 1;\n        }\n        getRightIndex(index) {\n            return index * 2 + 2;\n        }\n        getParentIndex(index) {\n            return Math.floor((index - 1) / 2);\n        }\n        swap(arr, a, b) {\n            [arr[a], arr[b]] = [arr[b], arr[a]];\n        }\n        preTraverseNode(index, cb) {\n            if (this.heap[index] !== undefined) {\n                cb(this.heap[index]);\n                this.preTraverseNode(this.getLeftIndex(index), cb);\n                this.preTraverseNode(this.getRightIndex(index), cb);\n            }\n        }\n        compare(a, b) {\n            return a >= b;\n        }\n        siftUp(index) {\n            let parent = this.getParentIndex(index);\n            while (index > 0 && this.compare(this.heap[parent], this.heap[index])) {\n                this.swap(this.heap, index, parent);\n                index = parent;\n                parent = this.getParentIndex(index);\n            }\n        }\n        shifDown(index) {\n            let left = this.getLeftIndex(index);\n            let right = this.getRightIndex(index);\n            if (this.compare(this.heap[index], this.heap[left]) && this.compare(this.heap[index], this.heap[right])) {\n                if (!this.compare(this.heap[right], this.heap[left])) {\n                    this.swap(this.heap, right, index);\n                    this.shifDown(right);\n                }\n                else {\n                    this.swap(this.heap, left, index);\n                    this.shifDown(left);\n                }\n            }\n            else if (this.compare(this.heap[index], this.heap[left])) {\n                this.swap(this.heap, left, index);\n                this.shifDown(left);\n            }\n            else if (this.compare(this.heap[index], this.heap[right])) {\n                this.swap(this.heap, right, index);\n                this.shifDown(right);\n            }\n        }\n        inster(value) {\n            this.heap.push(value);\n            this.siftUp(this.heap.length - 1);\n            return true;\n        }\n        extract() {\n            if (this.isEmpty()) {\n                return undefined;\n            }\n            if (this.size() == 1) {\n                return this.heap.unshift();\n            }\n            const removeValue = this.heap[0];\n            this.heap[0] = this.heap.pop();\n            this.shifDown(0);\n            return removeValue;\n        }\n        isEmpty() {\n            return this.size() == 0;\n        }\n        size() {\n            return this.heap.length;\n        }\n        preTraverse(cb) {\n            this.preTraverseNode(0, cb);\n        }\n    }\n})(structure || (structure = {}));\nvar structure;\n(function (structure) {\n    function quickSort(arr) {\n        quick(arr, 0, arr.length - 1);\n        return arr;\n    }\n    structure.quickSort = quickSort;\n    function quick(arr, left, right) {\n        if (arr.length > 1) {\n            let index = partition(arr, left, right);\n            console.log('index', index);\n            //两半局部有序分开  递归排序 分而治之\n            if (left < index - 1) {\n                quick(arr, left, index - 1);\n            }\n            if (index < right) {\n                quick(arr, index, right);\n            }\n        }\n    }\n    function partition(arr, left, right) {\n        //将数组 以pivot 为标准 划分为 两半 局部有序的\n        let pivot = arr[Math.floor((left + right) / 2)];\n        let i = left;\n        let j = right;\n        while (i <= j) {\n            while (arr[i] < pivot) {\n                i++;\n            }\n            while (arr[j] > pivot) {\n                j--;\n            }\n            if (i <= j) {\n                swap(arr, i, j);\n                i++;\n                j--;\n            }\n        }\n        return i;\n    }\n    function swap(arr, i, j) {\n        ;\n        [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n    let arr = [15, 4, 53, 1, 3, 3, 5, 45, 45];\n    quickSort(arr);\n    console.log(arr);\n})(structure || (structure = {}));\nvar sort;\n(function (sort) {\n    class bubbleSort {\n        sort(arr) {\n            for (let i = 0; i < arr.length - 1; i++) {\n                let complete = true;\n                for (let j = 0; j < arr.length - i; j++) {\n                    if (arr[j] > arr[j + 1]) {\n                        complete = false;\n                        [arr[j], arr[i]] = [arr[i], arr[j]];\n                    }\n                }\n                if (complete) {\n                    return;\n                }\n            }\n        }\n    }\n})(sort || (sort = {}));\nvar sort;\n(function (sort) {\n    class SelectionSort {\n        sort(arr) {\n            for (let i = 0; i < arr.length - 1; i++) {\n                let cur = i;\n                for (let j = i + 1; j < arr.length; j++) {\n                    if (arr[cur] > arr[j]) {\n                        cur = i;\n                    }\n                }\n                if (cur != i) {\n                    [arr[cur], arr[i]] = [arr[i], arr[cur]];\n                }\n            }\n        }\n    }\n})(sort || (sort = {}));\nvar sort;\n(function (sort) {\n    class insertionSort {\n        sort(arr) {\n            for (let i = 1; i < arr.length; i++) {\n                let j = i;\n                let tmp = arr[i];\n                while (j > 0 && arr[j - 1] > tmp) {\n                    arr[j] = arr[j - 1];\n                    j--;\n                }\n                arr[j] = tmp;\n            }\n        }\n    }\n})(sort || (sort = {}));\nvar sort;\n(function (sort) {\n    class shellSort {\n        sort(arr) {\n            let gap = Math.floor(arr.length / 2);\n            while (gap >= 1) {\n                for (let i = gap; i < arr.length; i++) {\n                    let j = i;\n                    let tmp = arr[i];\n                    while (j > gap - 1 && arr[j - gap] > tmp) {\n                        arr[j] = arr[j - gap];\n                        j -= gap;\n                    }\n                    arr[j] = tmp;\n                }\n            }\n            gap = Math.floor(gap / 2);\n        }\n    }\n})(sort || (sort = {}));\nvar sort;\n(function (sort) {\n    class quickSort {\n        sort(arr) {\n            this.quick(arr, 0, arr.length - 1);\n        }\n        quick(arr, left, right) {\n            if (arr.length < 0)\n                return;\n            let index = this.partition(arr, left, right);\n            if (index - 1 > left) {\n                this.partition(arr, left, index - 1);\n            }\n            else if (index < right) {\n                this.partition(arr, index, right);\n            }\n        }\n        partition(arr, left, right) {\n            let mid = arr[Math.floor((left + right) / 2)];\n            let i = left;\n            let j = right;\n            while (i < j) {\n                while (arr[i] < mid) {\n                    i++;\n                }\n                while (arr[j] > mid) {\n                    j--;\n                }\n                if (i < j) {\n                    [arr[i], arr[j]] = [arr[j], arr[i]];\n                    i++;\n                    j--;\n                }\n            }\n            return i;\n        }\n    }\n})(sort || (sort = {}));\nvar sort;\n(function (sort) {\n    class mergeSort {\n        sort(arr) {\n            let mid = Math.floor(arr.length / 2);\n            let left = this.sort(arr.slice(0, mid));\n            let right = this.sort(arr.slice(mid, arr.length));\n            arr = this.merge(left, right);\n            return arr;\n        }\n        merge(letf, right) {\n            let i = 0;\n            let j = 0;\n            let result = [];\n            while (i < letf.length && j < right.length) {\n                result.push(letf[i] < right[j] ? letf[i++] : right[j++]);\n            }\n            return result.concat(i < letf.length ? letf.slice(i) : right.slice(j));\n        }\n    }\n})(sort || (sort = {}));\n// 获取指定长度的斐波那契数列\nlet fibonacci = [];\nfibonacci[0] = 1;\nfibonacci[1] = 1;\nfor (let i = 2; i < 10; i++) {\n    fibonacci[i] = fibonacci[i - 1] + fibonacci[i - 2];\n}\n/* 数组中的插入操作 */\n// 01 尾部插入\n//原生\nfibonacci[fibonacci.length] = 0;\n//方法\nfibonacci.push(1);\n// 02 开头插入\n//原生\nfor (let i = fibonacci.length; i >= 0; i--) {\n    fibonacci[i] = fibonacci[i - 1];\n}\nfibonacci[0] = 300;\n//方法\nfibonacci.unshift(299);\n/* 数组中的删除操作 */\n// 01 末尾删除\n//方法\nfibonacci.pop();\n// 02 开头删除\n//原生\n//思路先执行覆盖 再将所有不是undefined的值移入新数组\n//执行覆盖操作\nfor (let i = 0; i < fibonacci.length; i++) {\n    fibonacci[i] = fibonacci[i + 1];\n}\n//将不是undefined的值移入newArray\nconst newArray = [];\nfor (let i = 0; i < fibonacci.length; i++) {\n    if (fibonacci[i] !== undefined) {\n        newArray.push(fibonacci[i]);\n    }\n}\nfibonacci = newArray;\n// 方法\nfibonacci.shift();\n/* 在任意位置添加或删除元素 */\n//使用splice方法\n//删除\nfibonacci.splice(fibonacci.length - 1, 1);\n//插入\nfibonacci.splice(1, 0, 0);\n/* 二维数组的迭代 */\nlet arrs = [\n    [1, 2, 3, 4],\n    [5, 6, 7, 8],\n    [9, 10]\n];\nfor (let i = 0; i < arrs.length; i++) {\n    for (let j = 0; j < arrs[i].length; j++) {\n        console.log(arrs[i][j]);\n    }\n}\nconsole.table(arrs);\n/* 多维数组 */\nlet many = [\n    [\n        [1, 2],\n        [3, 4]\n    ],\n    [\n        [5, 6],\n        [7, 8]\n    ],\n    [\n        [9, 10],\n        [11, 12]\n    ]\n];\nfor (let i = 0; i < many.length; i++) {\n    for (let j = 0; j < many[i].length; j++) {\n        for (let k = 0; k < many[i][j].length; k++) {\n            console.log(many[i][j][k]);\n        }\n    }\n}\n/*\nconcat 连接 2 个或更多数组，并返回结果\nevery 对数组中的每个元素运行给定函数，如果该函数对每个元素都返回 true，则返回 true\nfilter 对数组中的每个元素运行给定函数，返回该函数会返回 true 的元素组成的数组\nforEach 对数组中的每个元素运行给定函数。这个方法没有返回值\njoin 将所有的数组元素连接成一个字符串\nindexOf 返回第一个与给定参数相等的数组元素的索引，没有找到则返回-1\nlastIndexOf 返回在数组中搜索到的与给定参数相等的元素的索引里最大的值\nmap 对数组中的每个元素运行给定函数，返回每次函数调用的结果组成的数组\nreverse 颠倒数组中元素的顺序，原先第一个元素现在变成最后一个，同样原先的最后一个元素变成了现在\n的第一个\nslice 传入索引值，将数组里对应索引范围内的元素作为新数组返回\nsome 对数组中的每个元素运行给定函数，如果任一元素返回 true，则返回 true\nsort 按照字母顺序对数组排序，支持传入指定排序方法的函数作为参数\ntoString 将数组作为字符串返回\nvalueOf 和 toString 类似，将数组作为字符串返回\n */\n/* 数组合并 */\nconst zero = 0;\nconst positiveNumbers = [1, 2, 3];\nconst negativeNumbers = [-3, -2, -1];\nlet numbers = negativeNumbers.concat(zero, positiveNumbers);\n/* 迭代器函数 */\nconst isEven = (x) => x % 2 === 0;\n// 01 every方法\nconsole.log(numbers.every(isEven));\n// 02 some方法\nconsole.log(numbers.some(isEven));\n// 03 forEach\n// numbers.forEach((el) => console.log(el))\n// 04 map\nconst myMap = numbers.map((el) => el * 2);\n// 05 filter\nconst myFilter = numbers.filter(isEven);\n// 06 reduce\nconst myReduce = numbers.reduce((sum, el) => (sum = sum + el), 0);\n/* es2015 和 es2016 新增的数组方法\n@@iterator 返回一个包含数组键值对的迭代器对象，可以通过同步调用得到数组元素的键值对\ncopyWithin 复制数组中一系列元素到同一数组指定的起始位置\nentries 返回包含数组所有键值对的@@iterator\nincludes 如果数组中存在某个元素则返回 true，否则返回 false。E2016 新增\nfind 根据回调函数给定的条件从数组中查找元素，如果找到则返回该元素\nfindIndex 根据回调函数给定的条件从数组中查找元素，如果找到则返回该元素在数组中的索引\nfill 用静态值填充数组\nfrom 根据已有数组创建一个新数组\nkeys 返回包含数组所有索引的@@iterator\nof 根据传入的参数创建一个新数组\nvalues 返回包含数组中所有值的@@iterator\n*/\n/*    使用 @@iterator对象迭代  */\n/*\nlet iterator = numbers[Symbol.iterator]()\n\r\nconsole.log(iterator.next().value)\n\r\nfor (const n of iterator) {\n  console.log(n)\n}\n*/\n/* 中得到迭代器的方法 */\n// 01 使用entries =>得到键值对的迭代器\n/* let aEntries = numbers.entries()\n\r\nconsole.log(aEntries.next().value)\n\r\nfor (const n of aEntries) {\n  console.log(n)\n}\n */\n// 02 keys =>返回包含数组索引的@@iterator\n/* const aKeys = numbers.keys()\n\r\nconsole.log(aKeys.next()) */\n// 03 values => 返回包含数组值得 @@iterator\n/*\nconst aValues = numbers.values()\n\r\nconsole.log(aValues.next())\n\r\nfor (const n of aValues) {\n  console.log(n)\n}\n */\n/*  数组克隆方式  */\n// 01 Array.from方法\nlet numbers2 = Array.from(numbers, (el) => el * 3);\n// 02 Array.of方法\nlet tests = Array.of('4', '5', '6');\nlet numbers3 = Array.of(...numbers2);\n/* 数组的其他方法 */\n// 01 fill (target,start,end)\nnumbers3.fill(5, 2, 4);\n// 02 copyWithin  (target,start,end)\nnumbers3.copyWithin(0, 2, 4);\nlet arr = [1, 2, 3];\n//颠倒\narr.reverse();\n//排序\narr.sort();\n//自定义排序\nconst friends = [\n    { name: 'John', age: 30 },\n    { name: 'Ana', age: 20 },\n    { name: 'Chris', age: 25 }\n];\nfriends.sort((a, b) => a.age - b.age);\n//字符串排序\nlet names = ['Ana', 'ana', 'john', 'John'];\n// console.log(names.sort()) //[A J  a j]\nnames.sort((a, b) => b.localeCompare(a));\nconsole.log(names);\nlet arr1 = [1, 2, 3, 18];\n// console.log(arr1.indexOf(2))\n// console.log(arr1.lastIndexOf(1))\n// ES5 => find 和 findIndex\n// //find返回第一个符合函数查找的值 | undefined\n// console.log(arr1.find((el) => el > 20))\n// //findIndex回第一个符合函数查找的值的索引 | -1\n// console.log(arr1.findIndex((el) => el > 20))\n//ES7 => includes方法\n// console.log(arr1.includes(3))\n// console.log(arr1.includes(18, 4))\n/* 输出数组为字符串 */\nlet arr2 = [1, 2, 3];\nconsole.log(arr2.toString());\nconsole.log(arr2.join('-'));\n/* 扩展  MDN 文档 , Lo-Dash 处理数组方面实用的库 */\n/*\n与 C 和 Java 等其他语言不同，JavaScript 数组不是强类型的，因此它可以存储任意类型的数据。\n类型数组则用于存储单一类型的数据。它的语法是 let myArray = new TypedArray(length)，其中 TypedArray 需替换为下表所列之一。\n\r\n类型数组 数据类型\nInt8Array 8 位二进制补码整数\nUint8Array 8 位无符号整数\nUint8ClampedArray 8 位无符号整数\nInt16Array 16 位二进制补码整数\nUint16Array 16 位无符号整数\nInt32Array 32 位二进制补码整数\nUint32Array 32 位无符号整数\nFloat32Array 32 位 IEEE 浮点数\nFloat64Array 64 位 IEEE 浮点数\n */\n//example\nlet n = 5;\nlet int16 = new Int16Array(n);\nfor (let i = 0; i < n; i++) {\n    int16[i] = i + 1;\n}\nconsole.log(int16);\nfunction factorialIterative(n) {\n    if (n === 1 || n === 0) {\n        //出口\n        return 1;\n    }\n    return n * factorialIterative(n - 1); //入口\n}\nfunction getFibonacci(n) {\n    if (n < 1)\n        return 0;\n    if (n < 2)\n        return 1;\n    return getFibonacci(n - 1) + getFibonacci(n - 2);\n}\nfunction fibonacciMemoization() {\n    const memo = [0, 1];\n    const fibonacci = (n) => {\n        if (memo[n] != undefined) {\n            return memo[n];\n        }\n        return (memo[n] = fibonacci(n - 1) + fibonacci(n - 2));\n    };\n    return fibonacci;\n}\nconst find = (i, parent) => {\n    //查找 i元素的父节点 ,如果没有 返回 i\n    while (parent[i] !== -1) {\n        i = parent[i];\n    }\n    return i;\n};\nconst union = (i, j, parent) => {\n    if (i !== j) {\n        //父节点不相同 不是环  合并 否则是环 返回false\n        parent[j] = i;\n        return true;\n    }\n    return false;\n};\nconst getEdges = (graph) => {\n    //将图的所有边取出\n    const length = graph.length;\n    //用两个数组来表示\n    let edges = []; //存边的权\n    let vertices = []; // 存顶点\n    for (let i = 0; i < length; i++) {\n        for (let j = 0; j < length; j++) {\n            if (graph[i][j] !== 0) {\n                graph[j][i] = 0; //防止重复取边\n                vertices.push([i, j]); //存取边的顶点\n                edges.push(graph[i][j]); //存取边的权\n            }\n        }\n    }\n    return {\n        edges,\n        vertices\n    };\n};\nconst sortEdges = (edges = [], vertices = []) => {\n    //冒泡排序  将所有的边从小到大排列\n    for (let i = 0; i < edges.length - 1; i++) {\n        for (let j = 0; j < edges.length - i - 1; j++) {\n            if (edges[j] > edges[j + 1]) {\n                ;\n                [edges[j], edges[j + 1]] = [edges[j + 1], edges[j]];\n                [vertices[j], vertices[j + 1]] = [vertices[j + 1], vertices[j]];\n            }\n        }\n    }\n    return {\n        edges,\n        vertices\n    };\n};\nconst kruskal = (graph) => {\n    //克鲁斯卡尔 算法\n    //第一步  将图的 所有边 取出\n    let initEdeges = getEdges(graph);\n    //第二步  将所有的边 按权值 排序 由小到大\n    let { vertices } = sortEdges(initEdeges.edges, initEdeges.vertices);\n    //第三步 初始化变量\n    let res = [];\n    let parent = []; //存储并查集\n    let k = 0; //每次取一条边  K递增\n    for (let i = 0; i < graph.length; i++) {\n        parent[i] = -1;\n    }\n    // 第四步   取出边 插入图中,\n    // 直到插入 n-1条边 n代表 顶点的个数\n    while (res.length < graph.length - 1) {\n        let v = vertices[k];\n        //注意 要避免产生环  采用 并查集的方式 判断是否生成了环\n        const i = find(v[0], parent);\n        const j = find(v[1], parent);\n        if (union(i, j, parent)) {\n            //如果不是环 存入res中\n            res.push(v);\n        }\n        k++;\n    }\n    return res;\n};\nconst graph = [\n    [0, 2, 4, 0, 0, 0],\n    [2, 0, 2, 4, 2, 0],\n    [4, 2, 0, 0, 3, 0],\n    [0, 4, 0, 0, 3, 2],\n    [0, 2, 3, 3, 0, 2],\n    [0, 0, 0, 2, 2, 0]\n];\nconsole.log(kruskal(graph));\nfunction lcs(wordX, wordY) {\n    let f = [];\n    //初始化 f\n    for (let j = 0; j <= wordX.length; j++) {\n        f[j] = [];\n        f[j][0] = { value: 0, prev: null, x: j };\n    }\n    for (let i = 1; i <= wordY.length; i++) {\n        f[0][i] = { value: 0, prev: null, x: 0 };\n    }\n    //循环计算\n    for (let i = 1; i <= wordX.length; i++) {\n        for (let j = 1; j <= wordY.length; j++) {\n            if (wordX[i - 1] === wordY[j - 1]) {\n                f[i][j] = {\n                    value: f[i - 1][j - 1].value + 1,\n                    prev: f[i - 1][j - 1],\n                    x: i\n                };\n            }\n            else {\n                if (f[i - 1][j].value > f[i][j - 1].value) {\n                    f[i][j] = f[i - 1][j];\n                }\n                else {\n                    f[i][j] = f[i][j - 1];\n                }\n            }\n        }\n    }\n    return f[wordX.length][wordY.length];\n}\nfunction lcsToString(obj, str1) {\n    let current = obj;\n    let temp = [];\n    let res = '';\n    while (current.prev !== undefined) {\n        if (current.value === 0) {\n            break;\n        }\n        temp.push(current.x);\n        current = current.prev;\n    }\n    for (let i = temp.length - 1; i >= 0; i--) {\n        res = res + str1[temp[i] - 1];\n    }\n    return res;\n}\nconsole.log(lcsToString(lcs('abcadfk', 'acbaedk'), 'abcadfk'));\n//[a,c,b,a,e,d]\n//[a,b,c,a,d,f]\n//answer a c a d\n// f(x) =  { f(x-0)+a ,f(x-1) +c,}\n//  xm = yn => zk = xm = yn  //  且 Zk-1 是 Xm-1 和 Yn-1 的一个LCS\n//  xm != yn && zk !=xm !=yn // 则 Z 是 Xm-1 和 Yn-1 的一个LCS\n//  xm != yn  &&  zk != xm // 则 Z是 Xm-1和 Y 的一个LCS\n// xm != yn   &&  zk != yn // 则Z是X和Yn-1的一个LCS\n/*\n\r\n  c[i,j]  = {\n     0                    i = y = 0   ,\n\r\n   c[i-1,j-1] +1          xi=yi  ,\n\r\n   max(\n    c[i,j-1] ,c[i-1,j]\n     )                     xi!=yi\n\r\n}\n\r\n*/\n// x[A,C,B,A,E,D ]\n// y[A,B,C,A,D,F ]\n// c[0,0] = 0   ..c[0,n] = 0\n// c[1,0] = 0   ..c[1,1] = 1 ,  c[1,2] =  1 C[1,3] =1 ,C[1,4]\n// c[2,0] = 0    c[2,1] = 1    c[2,2] = 1  c[2,3] = 2\n//c[ 2 3 ] =\n// [A ,A ,C]\n// 对于矩阵链 M1 M2...Mi，矩阵 Mi的列数一定等于矩阵 Mi+1的行数（1≤i<n）\n//  因此，对于一个矩阵链，我们指定每个矩阵的行数和最右面矩阵MnMn的列数就可以了。\n//假设有n+1维数r1,r2,...,rn+1r1,r2,...,rn+1,这里riri表示矩阵MiMi的行数（1≤i≤n1≤i≤n），rn+1rn+1表示最矩阵MnMn的列数。\n//10,30  30 ,40 \n// [10,20] , [20,30] , [30,40]          //6000\n/*\n\r\n f (x) = max {\n  \r\n  \r\n}\n\r\n*/\n/**\n * ​\n1、首先在全局安装node.js\n\r\n2、在全局安装TS\n\r\nnpm install -g typescript\n\r\n2、创建 tsconfig.json                 运行\n  tsc --init\n ​\n3 创建packet.json\n npm init\n\r\n */ \n"],"file":"sort.js"}